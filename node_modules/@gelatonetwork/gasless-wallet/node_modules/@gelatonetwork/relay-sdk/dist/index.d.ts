import { BigNumber, ethers } from "ethers";
import { CallWithSyncFeeRequest } from "./lib/callWithSyncFee/types";
import { SponsoredCallRequest } from "./lib/sponsoredCall/types";
import { SponsoredCallERC2771Request } from "./lib/sponsoredCallERC2771/types";
import { TransactionStatusResponse } from "./lib/status/types";
import { RelayRequestOptions, RelayResponse } from "./lib/types";
export { CallWithSyncFeeRequest, SponsoredCallERC2771Request, SponsoredCallRequest, RelayRequestOptions, TransactionStatusResponse, RelayResponse, };
export declare class GelatoRelay {
    /**
     * @param {CallWithSyncFeeRequest} request - CallWithSyncFee request to be relayed by Gelato Executors
     * @param {RelayRequestOptions} [options] - Optional Relay configuration
     * @returns {Promise<RelayResponse>} Response object with taskId parameter
     *
     */
    callWithSyncFee: (request: CallWithSyncFeeRequest, options?: RelayRequestOptions | undefined) => Promise<RelayResponse>;
    /**
     * @param {SponsoredCallRequest} request SponsoredCallRequest to be relayed by the Gelato Executors.
     * @param {string} sponsorApiKey Sponsor API key to be used for the call
     * @param {RelayRequestOptions} [options] Optional Relay configuration
     * @returns {Promise<RelayResponse>} Response object with taskId parameter
     *
     */
    sponsoredCall: (request: SponsoredCallRequest, sponsorApiKey: string, options?: RelayRequestOptions | undefined) => Promise<RelayResponse>;
    /**
     * @param {SponsoredCallERC2771Request} request - SponsoredCallERC2771Request to be relayed by Gelato Executors
     * @param {ethers.providers.Web3Provider} provider - Web3Provider to sign the payload
     * @param {string} sponsorApiKey - Sponsor API key
     * @param {RelayRequestOptions} [options] - Optional Relay configuration
     * @returns {Promise<RelayResponse>} Response object with taskId parameter
     *
     */
    sponsoredCallERC2771: (request: SponsoredCallERC2771Request, provider: ethers.providers.Web3Provider, sponsorApiKey: string, options?: RelayRequestOptions | undefined) => Promise<RelayResponse>;
    /**
     * @param {number} chainId - Chain Id
     * @returns {Promise<boolean>} Boolean to demonstrate if Relay V2 is supported on the provided chain
     */
    isNetworkSupported: (chainId: number) => Promise<boolean>;
    /**
     * @returns {Promise<string[]>} List of networks where Relay V2 is supported
     */
    getSupportedNetworks: () => Promise<string[]>;
    /**
     * @param {number} chainId - Chain Id
     * @returns {Promise<boolean>} Boolean to demonstrate if the oracle is active on the provided chain
     */
    isOracleActive: (chainId: number) => Promise<boolean>;
    /**
     * @returns {Promise<string[]>} List of chain ids where the Gelato Oracle is active
     */
    getGelatoOracles: () => Promise<string[]>;
    /**
     * @param {number} chainId - Chain Id
     * @returns {Promise<string[]>} List of all payment tokens on the provided chain
     *
     */
    getPaymentTokens: (chainId: number) => Promise<string[]>;
    /**
     * @param {number} chainId - Chain Id
     * @param {string} paymentToken - Payment Token
     * @param {BigNumber} gasLimit - Gas Limit
     * @param {boolean} isHighPriority - Priority Level
     * @param {BigNumber} [gasLimitL1=BigNumber.from(0)] - Gas Limit for Layer 1
     * @returns {Promise<BigNumber>} Estimated Fee
     *
     */
    getEstimatedFee: (chainId: number, paymentToken: string, gasLimit: BigNumber, isHighPriority: boolean, gasLimitL1?: BigNumber) => Promise<BigNumber>;
    /**
     * @param {string} taskId - Task Id
     * @returns {Promise<TransactionStatusResponse | undefined>} Transaction status of the task id
     *
     */
    getTaskStatus: (taskId: string) => Promise<TransactionStatusResponse | undefined>;
}
